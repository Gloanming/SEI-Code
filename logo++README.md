# LOGO++

## 题目背景

同学们在上一次作业中完成了一个简单的LOGO模拟器，可以进行简单的绘画功能。这次同学们可以完成一些复杂指令，实现一些对复杂图形的绘制！

本次作业首先新增了两条指令：pen_up和pen_down，表示暂停或开始绘画模式。在暂停绘画的状态下小乌龟移动不会在路径上留下字符，只有在开始绘画的状态下才会留下字符。原有的移动功能会以move开头，操作数不变。然后新增三条复杂指令：cross、rect、rect_f。cross命令有1或2个操作数。rect、rect_f有2或3个操作数。最后还有一条指令end，它会结束绘图程序并输出棋盘。

cross命令会以小乌龟为中心画一个十字，十字的长度为第一个操作数，绘画的字符使用第二个操作数（如没有则沿用之前的画笔）。rect命令会以小乌龟的起始位置为左上角，向右下画出一个矩形。矩形的横向、纵向宽度分别为第一个、第二个操作数。第三个操作数同样是指定可能的画笔字符。rect_f命令大体与rect命令相同，但它会用当前的画笔填充所画的矩形。以上三种指令执行完毕后，小乌龟需要回到原先的位置，即指令不会让它的位置改变。

同样的，小乌龟不能移到屏幕外面，一旦出现则输出Error并结束模拟。

tips

1：以上几条命令能否用已有的move指令和pen_up、pen_down指令组合实现？

2：如果将move封装为函数，如何实现在移动完成后改变小乌龟的状态？

3：你可以实现一条print指令来便于你调试。测试用例里不会出现该条指令。

4：在题目中未明确的指令组合（比如连续两次pen_up）属于未定义行为。未定义行为你可以任意实现，测试用例中不会出现未定义行为。

## 输入格式

若干行指令，每行有指令的名称与一定数量的操作数。

最后一行一定是end指令。

## 输出格式

Error!或10行10列字符，表示最后的棋盘的结果。

## 样例

### 输入

```
rect 3 5 a
end
```

### 输出

```
aaa0000000
a0a0000000
a0a0000000
a0a0000000
aaa0000000
0000000000
0000000000
0000000000
0000000000
0000000000
```

同样的，此处的‘0’代表空白符，实际输出需用空白符代替。

### 输入

```
rect_f 4 6 b
end
```

### 输出

```
bbbb000000
bbbb000000
bbbb000000
bbbb000000
bbbb000000
bbbb000000
0000000000
0000000000
0000000000
0000000000
```

### 输入

```
pen_up
move D 3
move R 3
pen_down
cross 3 c
end
```

### 输出

```
000c000000
000c000000
000c000000
ccccccc000
000c000000
000c000000
000c000000
0000000000
0000000000
0000000000
```

在cross指令完毕后，小乌龟停在第四行第四列的位置。

### 输入

```
pen_up
move D 3
move R 3
pen_down
cross 4 c
end
```

### 输出

```
Error!
```

## 输入规则

指令条数1<=n<=20，保证不会出现不符合格式的指令。每次移动步数不会为0。指令序列中第一条在开始绘画状态下执行的指令一定有要画的字符。

项目说明：

>src目录下为题目代码源文件，需要完成的内容为logo.py里的logo_play()方法。
>src目录下的__init__.py文件不需要改动。


